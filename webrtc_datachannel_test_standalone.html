<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC DataChannel Fix Test - Standalone</title>
    <style>
        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            margin: 20px;
            background-color: #1a1a1a;
            color: #e0e0e0;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        .status {
            padding: 12px;
            margin: 10px 0;
            border-radius: 8px;
            border-left: 4px solid;
        }
        .success {
            background: #0f2419;
            color: #4ade80;
            border-left-color: #4ade80;
        }
        .error {
            background: #2d1b1b;
            color: #f87171;
            border-left-color: #f87171;
        }
        .warning {
            background: #2d2916;
            color: #fbbf24;
            border-left-color: #fbbf24;
        }
        .info {
            background: #1e2837;
            color: #60a5fa;
            border-left-color: #60a5fa;
        }

        button {
            padding: 12px 24px;
            margin: 8px 4px;
            border: none;
            border-radius: 6px;
            background: #3b82f6;
            color: white;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
            transition: all 0.2s;
        }
        button:hover { background: #2563eb; transform: translateY(-1px); }
        button:disabled { background: #6b7280; cursor: not-allowed; transform: none; }

        textarea {
            width: 100%;
            height: 400px;
            background: #111827;
            color: #e5e7eb;
            border: 1px solid #374151;
            border-radius: 6px;
            padding: 12px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 12px;
            line-height: 1.4;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .panel {
            background: #111827;
            border: 1px solid #374151;
            border-radius: 8px;
            padding: 20px;
        }

        .state-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .state-unknown { background: #6b7280; }
        .state-new { background: #8b5cf6; }
        .state-connecting { background: #f59e0b; }
        .state-connected { background: #10b981; }
        .state-disconnected { background: #ef4444; }
        .state-failed { background: #dc2626; }
        .state-closed { background: #374151; }

        .datachannel-unknown { background: #6b7280; }
        .datachannel-connecting { background: #f59e0b; }
        .datachannel-open { background: #10b981; }
        .datachannel-closing { background: #f97316; }
        .datachannel-closed { background: #374151; }

        h1, h2, h3 { color: #f9fafb; }
        code {
            background: #374151;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: inherit;
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
            margin: 16px 0;
        }

        .metric {
            background: #1f2937;
            padding: 12px;
            border-radius: 6px;
            text-align: center;
        }

        .metric-label {
            font-size: 12px;
            color: #9ca3af;
            margin-bottom: 4px;
        }

        .metric-value {
            font-size: 18px;
            font-weight: bold;
            color: #f9fafb;
        }

        .test-section {
            background: #1f2937;
            padding: 16px;
            margin: 16px 0;
            border-radius: 8px;
            border: 1px solid #374151;
        }

        .fix-demo {
            background: #0f2419;
            border: 1px solid #4ade80;
            padding: 16px;
            margin: 16px 0;
            border-radius: 8px;
        }

        .original-problem {
            background: #2d1b1b;
            border: 1px solid #f87171;
            padding: 16px;
            margin: 16px 0;
            border-radius: 8px;
        }

        pre {
            background: #111827;
            padding: 12px;
            border-radius: 6px;
            overflow-x: auto;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç WebRTC DataChannel Fix Test - Standalone</h1>
        <p>This page tests the DataChannel state checking fixes without requiring a server.</p>

        <div class="fix-demo">
            <h3>‚úÖ Fix Demonstration</h3>
            <p>The original error was:</p>
            <code>InvalidStateError: Failed to execute 'send' on 'RTCDataChannel': RTCDataChannel.readyState is not 'open'</code>
            <p>Our fix adds proper state checking before sending data through DataChannels.</p>
        </div>

        <div class="panel">
            <h2>üéÆ Test Controls</h2>
            <button onclick="startLocalTest()">Start Local DataChannel Test</button>
            <button onclick="simulateRaceCondition()">Simulate Race Condition</button>
            <button onclick="testStateFix()">Test State Fix</button>
            <button onclick="clearLogs()">Clear Logs</button>
            <button onclick="exportLogs()">Export Logs</button>
        </div>

        <div class="grid">
            <div class="panel">
                <h3>üìä DataChannel States</h3>
                <div id="connection-status">
                    <p><span class="state-indicator datachannel-unknown" id="pc1-indicator"></span> <strong>Peer 1 Channel:</strong> <span id="pc1-state">unknown</span></p>
                    <p><span class="state-indicator datachannel-unknown" id="pc2-indicator"></span> <strong>Peer 2 Channel:</strong> <span id="pc2-state">unknown</span></p>
                    <p><strong>Connection State:</strong> <span id="connection-state">not started</span></p>
                </div>

                <h3>üìà Test Results</h3>
                <div class="metrics">
                    <div class="metric">
                        <div class="metric-label">Safe Sends</div>
                        <div class="metric-value" id="safe-sends">0</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Blocked Sends</div>
                        <div class="metric-value" id="blocked-sends">0</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Errors Prevented</div>
                        <div class="metric-value" id="errors-prevented">0</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Total Tests</div>
                        <div class="metric-value" id="total-tests">0</div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h3>üß™ Code Comparison</h3>
                <div class="original-problem">
                    <h4>‚ùå Original Problematic Code:</h4>
                    <pre><code>// This caused the InvalidStateError
channel.send(json.dumps({
    'type': 'chat',
    'message': 'Hello!'
}));</code></pre>
                </div>

                <div class="fix-demo">
                    <h4>‚úÖ Fixed Code:</h4>
                    <pre><code>// Now with proper state checking
if (channel && channel.readyState === 'open') {
    channel.send(JSON.stringify({
        'type': 'chat',
        'message': 'Hello!'
    }));
} else {
    console.warn('Channel not ready:',
                 channel?.readyState || 'null');
}</code></pre>
                </div>
            </div>
        </div>

        <div class="panel">
            <h3>üîç Test Log</h3>
            <div id="status-container"></div>
            <textarea id="debug-log" readonly placeholder="Test results will appear here..."></textarea>
        </div>

        <div class="test-section">
            <h3>üìã Fix Implementation Details</h3>
            <p><strong>Files Modified:</strong></p>
            <ul>
                <li><code>src/service/rtc_service/rtc_stream.py</code> - Added safe_channel_send function</li>
                <li><code>src/third_party/gradio_webrtc_videochat/backend/fastrtc/tracks.py</code> - Added state checks</li>
                <li><code>src/third_party/gradio_webrtc_videochat/backend/fastrtc/utils.py</code> - Enhanced send validation</li>
                <li><code>src/third_party/gradio_webrtc_videochat/backend/fastrtc/reply_on_stopwords.py</code> - Safe stopword sending</li>
                <li><code>src/third_party/gradio_webrtc_videochat/backend/fastrtc/webrtc_connection_mixin.py</code> - Better error handling</li>
            </ul>

            <p><strong>Key Improvements:</strong></p>
            <ul>
                <li>‚úÖ State validation before all DataChannel send operations</li>
                <li>‚úÖ Comprehensive error logging with channel state information</li>
                <li>‚úÖ Graceful degradation when channels aren't ready</li>
                <li>‚úÖ Prevention of InvalidStateError exceptions</li>
                <li>‚úÖ Enhanced debugging capabilities</li>
            </ul>
        </div>
    </div>

    <script>
        // Global variables
        let pc1 = null;
        let pc2 = null;
        let dc1 = null;
        let dc2 = null;
        let testMetrics = {
            safeSends: 0,
            blockedSends: 0,
            errorsPrevented: 0,
            totalTests: 0
        };

        // DOM elements
        const debugLog = document.getElementById('debug-log');
        const statusContainer = document.getElementById('status-container');

        // Enhanced logging function
        function log(message, type = 'info', skipConsole = false) {
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] ${message}`;

            debugLog.value += logMessage + '\n';
            debugLog.scrollTop = debugLog.scrollHeight;

            // Update status container
            const statusDiv = document.createElement('div');
            statusDiv.className = `status ${type}`;
            statusDiv.textContent = message;
            statusContainer.appendChild(statusDiv);

            // Keep only last 10 status messages
            while (statusContainer.children.length > 10) {
                statusContainer.removeChild(statusContainer.firstChild);
            }

            if (!skipConsole) {
                console.log(`üîç ${logMessage}`);
            }
        }

        // Our improved safe send function (JavaScript version)
        function safeSend(channel, messageData, messageType = 'message') {
            testMetrics.totalTests++;

            if (!channel) {
                log(`‚ùå Cannot send ${messageType}: channel is null`, 'error');
                testMetrics.blockedSends++;
                testMetrics.errorsPrevented++;
                updateMetrics();
                return false;
            }

            if (!channel.readyState) {
                log(`‚ùå Cannot send ${messageType}: channel has no readyState`, 'error');
                testMetrics.blockedSends++;
                testMetrics.errorsPrevented++;
                updateMetrics();
                return false;
            }

            if (channel.readyState !== 'open') {
                log(`‚ùå Cannot send ${messageType}: channel state is '${channel.readyState}', expected 'open'`, 'warning');
                testMetrics.blockedSends++;
                testMetrics.errorsPrevented++;
                updateMetrics();
                return false;
            }

            try {
                const messageStr = typeof messageData === 'string' ? messageData : JSON.stringify(messageData);
                channel.send(messageStr);
                log(`‚úÖ Successfully sent ${messageType}`, 'success');
                testMetrics.safeSends++;
                updateMetrics();
                return true;
            } catch (error) {
                log(`‚ùå Failed to send ${messageType}: ${error.message}`, 'error');
                testMetrics.blockedSends++;
                updateMetrics();
                return false;
            }
        }

        // Simulate the old problematic way (for demonstration)
        function unsafeSend(channel, messageData, messageType = 'message') {
            testMetrics.totalTests++;
            try {
                if (!channel) {
                    throw new Error('Channel is null');
                }
                const messageStr = typeof messageData === 'string' ? messageData : JSON.stringify(messageData);
                channel.send(messageStr); // This would cause InvalidStateError if channel isn't open
                log(`üì§ Unsafe send of ${messageType} succeeded (lucky!)`, 'info');
                testMetrics.safeSends++;
            } catch (error) {
                log(`üí• Unsafe send failed with: ${error.name}: ${error.message}`, 'error');
                if (error.name === 'InvalidStateError') {
                    log(`üéØ This is the exact error we fixed!`, 'warning');
                }
                testMetrics.blockedSends++;
            }
            updateMetrics();
        }

        function updateMetrics() {
            document.getElementById('safe-sends').textContent = testMetrics.safeSends;
            document.getElementById('blocked-sends').textContent = testMetrics.blockedSends;
            document.getElementById('errors-prevented').textContent = testMetrics.errorsPrevented;
            document.getElementById('total-tests').textContent = testMetrics.totalTests;
        }

        function updateChannelStates() {
            const pc1State = dc1 ? dc1.readyState : 'null';
            const pc2State = dc2 ? dc2.readyState : 'null';

            document.getElementById('pc1-state').textContent = pc1State;
            document.getElementById('pc2-state').textContent = pc2State;

            // Update indicators
            const pc1Indicator = document.getElementById('pc1-indicator');
            const pc2Indicator = document.getElementById('pc2-indicator');

            pc1Indicator.className = `state-indicator datachannel-${pc1State}`;
            pc2Indicator.className = `state-indicator datachannel-${pc2State}`;

            // Update connection state
            if (pc1State === 'open' && pc2State === 'open') {
                document.getElementById('connection-state').textContent = 'Both channels open';
            } else if (pc1State === 'connecting' || pc2State === 'connecting') {
                document.getElementById('connection-state').textContent = 'Connecting...';
            } else if (pc1State === 'closed' && pc2State === 'closed') {
                document.getElementById('connection-state').textContent = 'Closed';
            } else {
                document.getElementById('connection-state').textContent = `PC1: ${pc1State}, PC2: ${pc2State}`;
            }
        }

        async function startLocalTest() {
            try {
                log('üöÄ Starting local DataChannel test...', 'info');

                // Clean up existing connections
                if (pc1) pc1.close();
                if (pc2) pc2.close();

                // Create peer connections
                const configuration = {
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                };

                pc1 = new RTCPeerConnection(configuration);
                pc2 = new RTCPeerConnection(configuration);

                // Set up data channel on pc1
                dc1 = pc1.createDataChannel('test', { ordered: true });

                // Handle data channel from pc1 on pc2
                pc2.ondatachannel = (event) => {
                    dc2 = event.channel;
                    setupDataChannelHandlers(dc2, 'PC2');
                    updateChannelStates();
                };

                setupDataChannelHandlers(dc1, 'PC1');

                // Set up ICE candidate exchange
                pc1.onicecandidate = (event) => {
                    if (event.candidate) {
                        pc2.addIceCandidate(event.candidate);
                    }
                };

                pc2.onicecandidate = (event) => {
                    if (event.candidate) {
                        pc1.addIceCandidate(event.candidate);
                    }
                };

                // Create offer and establish connection
                const offer = await pc1.createOffer();
                await pc1.setLocalDescription(offer);
                await pc2.setRemoteDescription(offer);

                const answer = await pc2.createAnswer();
                await pc2.setLocalDescription(answer);
                await pc1.setRemoteDescription(answer);

                log('‚úÖ WebRTC connection established', 'success');
                updateChannelStates();

            } catch (error) {
                log(`‚ùå Failed to start local test: ${error.message}`, 'error');
            }
        }

        function setupDataChannelHandlers(channel, peerName) {
            channel.onopen = () => {
                log(`‚úÖ ${peerName} DataChannel opened`, 'success');
                updateChannelStates();

                // Test safe send immediately when channel opens
                setTimeout(() => {
                    safeSend(channel, {
                        type: 'test',
                        message: `Hello from ${peerName}!`,
                        timestamp: Date.now()
                    }, `${peerName} greeting`);
                }, 100);
            };

            channel.onclose = () => {
                log(`üì™ ${peerName} DataChannel closed`, 'info');
                updateChannelStates();
            };

            channel.onerror = (error) => {
                log(`‚ùå ${peerName} DataChannel error: ${error}`, 'error');
                updateChannelStates();
            };

            channel.onmessage = (event) => {
                log(`üì® ${peerName} received: ${event.data}`, 'success');
                try {
                    const data = JSON.parse(event.data);
                    log(`Message type: ${data.type}`, 'info', true);
                } catch (e) {
                    log('Message is not JSON', 'info', true);
                }
            };
        }

        function simulateRaceCondition() {
            log('üéØ Simulating race condition scenario...', 'info');

            // Create a mock channel in different states
            const states = ['connecting', 'open', 'closing', 'closed'];

            states.forEach((state, index) => {
                setTimeout(() => {
                    const mockChannel = { readyState: state, label: 'mock' };

                    // Add a mock send function that throws InvalidStateError for non-open states
                    mockChannel.send = function(data) {
                        if (this.readyState !== 'open') {
                            throw new DOMException(
                                `Failed to execute 'send' on 'RTCDataChannel': RTCDataChannel.readyState is not 'open'`,
                                'InvalidStateError'
                            );
                        }
                        log(`üì§ Mock send successful in state: ${this.readyState}`, 'success');
                    };

                    log(`üß™ Testing with channel state: ${state}`, 'info');

                    // Test our safe send vs unsafe send
                    log(`Testing SAFE send with state '${state}'...`, 'info');
                    safeSend(mockChannel, { test: 'safe' }, `safe test (${state})`);

                    log(`Testing UNSAFE send with state '${state}'...`, 'info');
                    unsafeSend(mockChannel, { test: 'unsafe' }, `unsafe test (${state})`);

                }, index * 1000);
            });
        }

        function testStateFix() {
            log('üîß Testing state checking fix...', 'info');

            // Test various edge cases
            const testCases = [
                { channel: null, description: 'null channel' },
                { channel: {}, description: 'channel without readyState' },
                { channel: { readyState: 'connecting' }, description: 'connecting channel' },
                { channel: { readyState: 'closing' }, description: 'closing channel' },
                { channel: { readyState: 'closed' }, description: 'closed channel' },
                {
                    channel: {
                        readyState: 'open',
                        send: (data) => log(`üì§ Mock successful send: ${data}`, 'success')
                    },
                    description: 'open channel (should work)'
                }
            ];

            testCases.forEach((testCase, index) => {
                setTimeout(() => {
                    log(`üß™ Testing ${testCase.description}...`, 'info');
                    safeSend(testCase.channel, { test: `case ${index}` }, testCase.description);
                }, index * 500);
            });
        }

        function clearLogs() {
            debugLog.value = '';
            statusContainer.innerHTML = '';
            testMetrics = { safeSends: 0, blockedSends: 0, errorsPrevented: 0, totalTests: 0 };
            updateMetrics();
            log('üßπ Logs cleared and metrics reset', 'info');
        }

        function exportLogs() {
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            const logData = {
                timestamp: timestamp,
                logs: debugLog.value,
                metrics: testMetrics,
                userAgent: navigator.userAgent,
                webRTCSupport: !!window.RTCPeerConnection
            };

            const blob = new Blob([JSON.stringify(logData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `webrtc-datachannel-test-${timestamp}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            log('üìÅ Test results exported', 'success');
        }

        // Initialize the page
        window.onload = () => {
            log('üåü WebRTC DataChannel Fix Test loaded', 'success');
            log(`User Agent: ${navigator.userAgent}`, 'info', true);
            log(`WebRTC Support: ${!!window.RTCPeerConnection}`, 'info');
            log(`DataChannel Support: ${!!window.RTCDataChannel}`, 'info');

            updateChannelStates();
            updateMetrics();

            log('üí° Click "Start Local DataChannel Test" to create a peer-to-peer connection', 'info');
            log('üí° Click "Simulate Race Condition" to see how our fix prevents errors', 'info');
            log('üí° Click "Test State Fix" to test various edge cases', 'info');
        };

        // Update states periodically
        setInterval(updateChannelStates, 1000);
    </script>
</body>
</html>
